#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
C-phase output generator: produce a compact race list (no money) from the prediction report.

Input:  *_report.csv generated by boatrace_backtest_v12_prune_configurable_s087_alltracks*.py
Output: CSV + TXT containing (date, jcd, race_no, tier, conf, axis1, axis2, short_reason)

Usage:
  python scripts/c_out_emit_summary.py --report <report.csv> --out <out.csv> [--txt <out.txt>]
"""
from __future__ import annotations
import argparse
from pathlib import Path
import pandas as pd

BASE_COLS = [
    "date","jcd","race_no",
    "tier_raw","tier",
    "conf","tier_conf",
    "axis1","axis2",
]

def pick_conf(df: pd.DataFrame) -> pd.Series:
    if "conf" in df.columns:
        return pd.to_numeric(df["conf"], errors="coerce")
    if "tier_conf" in df.columns:
        return pd.to_numeric(df["tier_conf"], errors="coerce")
    return pd.Series([pd.NA]*len(df), index=df.index)

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--report", required=True)
    ap.add_argument("--out", required=True)
    ap.add_argument("--txt", default=None)
    args = ap.parse_args()

    rep = Path(args.report)
    out = Path(args.out)
    txt = Path(args.txt) if args.txt else None

    df = pd.read_csv(rep, encoding="utf-8-sig")
    for c in ["date","jcd","race_no"]:
        if c not in df.columns:
            raise SystemExit(f"[C_OUT] missing column in report: {c}")

    # Build output
    cols = [c for c in BASE_COLS if c in df.columns]
    out_df = df[cols].copy()
    out_df["conf"] = pick_conf(df)

    # Short reason if present
    reason_cols = [c for c in df.columns if c.startswith("reason_")]
    if reason_cols:
        def make_reason(row):
            parts=[]
            for rc in reason_cols:
                v=row.get(rc)
                if pd.isna(v):
                    continue
                s=str(v).strip()
                if s and s!="nan":
                    parts.append(s)
                if len(parts)>=2:
                    break
            return " / ".join(parts) if parts else ""
        out_df["reason"] = df.apply(make_reason, axis=1)

    # Tier sort: S then A then others
    if "tier_raw" in out_df.columns:
        tier_order={"S":0,"A":1}
        out_df["_tier_ord"]=out_df["tier_raw"].map(tier_order).fillna(9)
    else:
        out_df["_tier_ord"]=9

    out_df = out_df.sort_values(
        by=["_tier_ord","conf","jcd","race_no"],
        ascending=[True,False,True,True],
        na_position="last"
    ).drop(columns=["_tier_ord"])

    out.parent.mkdir(parents=True, exist_ok=True)
    out_df.to_csv(out, index=False, encoding="utf-8-sig")

    if txt:
        lines=[]
        for _,r in out_df.iterrows():
            d=str(r.get("date",""))
            j=str(r.get("jcd",""))
            rn=str(r.get("race_no",""))
            tier=str(r.get("tier_raw", r.get("tier","")))
            conf=r.get("conf", pd.NA)
            ax1=r.get("axis1","")
            ax2=r.get("axis2","")
            reason=r.get("reason","")
            conf_s = f"{float(conf):.3f}" if pd.notna(conf) else ""
            line=f"{d} jcd={j} R{rn} {tier} conf={conf_s} axis={ax1}/{ax2}"
            if reason:
                line += f" | {reason}"
            lines.append(line)
        txt.parent.mkdir(parents=True, exist_ok=True)
        txt.write_text("\n".join(lines), encoding="utf-8")

    print(f"[C_OUT] wrote: {out}")
    if txt:
        print(f"[C_OUT] wrote: {txt}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
